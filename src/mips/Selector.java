/*
The first step is to build an instruction selector that transforms Tiger-IR 
instructions to MIPS3 instructions that operate on an unlimited number of 
virtual registers. 

It is fine if the instructions generated by your project include pseudo 
instructions supported by SPIM. The main criterion is that the code that 
you generate must be executable on the SPIM simulator. 

It will suffice to implement a simple instruction selector that translates 
one IR instruction at a time. Also, note that all the intrinsic functions 
in Tiger-IR can be implemented using SPIM system calls.
*/

import ir.*;
import ir.datatype.*;
import ir.operand.*;
import mips.*;
import mips.operand.*;

import java.util.Arrays;
import java.util.List;
import java.util.LinkedList;
import java.util.Map;
import java.util.HashMap;
import java.util.Collections;

public class Selector {

	public Map<String, Register> regs;
	// public Map<String, Addr> labelMap;
	// public Map<String, String> irToMipsRegMap;
	// public Map<String, Integer> assignments;

	public List<MIPSFunction> processedFunctions;
	public MIPSFunction curFunction;

	public Addr stackPointer;
	public Imm wordSize;
	public Imm negWordSize;

	private boolean USING_SPIM = false;		//// Set false when using mips-interpreter, else true
	private boolean SUPPORT_FLOATS = false;
	private boolean USE_SYMBOLIC = true;
	private static int tNum = 10;
	private static int aNum = 4;

	private int FP_OFFSET_T0 = -4;
	private int FP_OFFSET_T9 = -40;
	private Imm NEG_ONE;
	private Imm ZERO;
	private Imm ONE;
	private Imm TWO;

	private boolean SAVE_RESTORE_FROM_FP = false;
	private Imm posTempRegSpace;
	private Imm negTempRegSpace;

	private String[] tempRegNames = {"$t0", "$t1", "$t2", "$t3", "$t4", "$t5", "$t6", "$t7", "$t8", "$t9"};
	private Map<String, Addr> tempRegFrameOffsets;
	private Map<String, Addr[]> tempRegOffsets;
	private String[] argRegNames = {"$a0", "$a1", "$a2", "$a3"};
	private String[] intrinsicFunctions = {"geti", "getf", "getc", "puti", "putf", "putc"};
	private Map<String, Imm> systemServiceCodes;

	public Map<String, MIPSArray> processedArrays;

	public Selector() { 
		// labelMap = new HashMap<>();
		// irToMipsRegMap = new HashMap<>();
		// assignments = new HashMap<>();

		processedFunctions = new LinkedList<>();
		curFunction = null;

		NEG_ONE = new Imm("-1");
		ZERO = new Imm("0");
		ONE = new Imm("1");
		TWO = new Imm("2");
		wordSize = new Imm("4");
		negWordSize = new Imm("-4");
		posTempRegSpace = new Imm("40");
		negTempRegSpace = new Imm("-40");

		initializeRegisters();

		if (SAVE_RESTORE_FROM_FP) {
			tempRegFrameOffsets = new HashMap<>();
			int fpOffset = -4;
			for (String name : tempRegNames) {
				Addr offset = new Addr(new Imm(String.valueOf(fpOffset)), regs.get("$fp"));
				tempRegFrameOffsets.put(name, offset);
				fpOffset -= 4;
			}
			if (fpOffset != -40 && fpOffset != -44) {
				System.out.println("[Selector] Error occurred while initializing tempRegFrameOffsets:  fpOffset = " + String.valueOf(fpOffset));
			}
		} else {
			tempRegOffsets = new HashMap<>();
			int spOffset = 0;
			for (String name : tempRegNames) {
				Addr[] offsets = new Addr[]{
						new Addr(new Imm(String.valueOf(spOffset*(-1))), regs.get("$sp")),
						new Addr(new Imm(String.valueOf(spOffset)), regs.get("$sp"))};
				tempRegOffsets.put(name, offsets);
				spOffset += 4;
			}
		}

		initializeSystemServices();

		stackPointer = new Addr(ZERO, regs.get("$sp"));

		processedArrays = new HashMap<>();
	}

	private String findUnusedRegName() {
		if (curFunction != null) {
			//// Find an unused temporary register to map the operand/variable name to
			for (String name : tempRegNames) {
				if (!curFunction.irToMipsRegMap.containsValue(name)) {
					return name;
				}
			}
		}
		return null;
	}

	private Register getMappedReg(String operand) {
		String associatedRegName = null;
		if (curFunction == null) {
			return null;
		}
		if (curFunction.irToMipsRegMap.containsKey(operand)) {
			associatedRegName = curFunction.irToMipsRegMap.get(operand);
			// return regs.get(associatedRegName);
		}
		else {
			/*
			//// Find an unused temporary register to map the operand/variable name to
			for (String name : tempRegNames) {
				if (!irToMipsRegMap.containsValue(name)) {
					associatedRegName = name;
					irToMipsRegMap.put(operand, associatedRegName);
					break;
				}
			}
			*/
			associatedRegName = findUnusedRegName();
			if (associatedRegName != null) {
				curFunction.irToMipsRegMap.put(operand, associatedRegName);

				//// UPDATE (4/22/20): mips-interpreter sometimes fails due to uninitialized registers; here's a dumb fix:
				// curFunction.instructions.add(new MIPSInstruction(MIPSOp.LI, null, regs.get(associatedRegName), ZERO));

			}
		}

		if (associatedRegName == null) {
			if (USE_SYMBOLIC) {
				String virtualRegName = "$t" + String.valueOf(tNum) + curFunction.name; //"Virtual";
				tNum++;
				regs.put(virtualRegName, new Register(virtualRegName));
				curFunction.irToMipsRegMap.put(operand, virtualRegName);
				associatedRegName = virtualRegName;

				//// Need to initialize virtual registers before they can be used
				curFunction.instructions.add(new MIPSInstruction(MIPSOp.LI, null, regs.get(virtualRegName), ZERO));
			} else {
				System.out.println("[getMappedReg] ERROR: Could not assign a temporary register to operand '"+operand+"'");
				return null;
			}
		}
		return regs.get(associatedRegName);
	}

	private Register getArgumentReg(String arg) {
		String argRegName = null;
		if (curFunction == null) {
			return null;
		}
		if (curFunction.irToMipsRegMap.containsKey(arg)) {
			argRegName = curFunction.irToMipsRegMap.get(arg);
		}
		else {
			for (String name : argRegNames) {
				if (!curFunction.irToMipsRegMap.containsValue(name)) {
					argRegName = name;
					break;
				}
			}
			if (argRegName != null) {
				curFunction.irToMipsRegMap.put(arg, argRegName);
			}
		}

		if (argRegName == null) {
			if (USE_SYMBOLIC) {
				String virtualArgName = "$a" + String.valueOf(aNum) + curFunction.name;
				aNum++;
				regs.put(virtualArgName, new Register(virtualArgName));
				curFunction.irToMipsRegMap.put(arg, virtualArgName);
				argRegName = virtualArgName;

				//// Need to initialize virtual registers before they can be used
				curFunction.instructions.add(new MIPSInstruction(MIPSOp.LI, null, regs.get(virtualArgName), new Imm("0")));
			} else {
				System.out.println("[getArgumentReg] ERROR: Could not assign a free register for argument '"+arg+"'");
				// return null;
				return getMappedReg(arg);
			}
		}
		return regs.get(argRegName);
	}

	public MIPSFunction parseFunction(IRFunction irFunction) {
		MIPSFunction mipsFunction = new MIPSFunction(irFunction.name);
		processedFunctions.add(mipsFunction);
		curFunction = mipsFunction;

		curFunction.labelMap.put(irFunction.name, new Addr(irFunction.name));

		//// Generate function name label as first instruction
        mipsFunction.instructions.add(0, new MIPSInstruction(MIPSOp.LABEL, 
        		irFunction.name, (MIPSOperand[]) null));

//---------------------------------------------------------------------------------------------------

        mipsFunction.instructions.add(new MIPSInstruction(MIPSOp.COMMENT, 
					"Start of prologue", 
					(MIPSOperand) null));

        /* Stack Frame Prologue Step #1: Set up current frame pointer (copy $sp to $fp) */
        //// Generate first true instruction ("move $fp, $sp")
        if ("main".equalsIgnoreCase(mipsFunction.name)) {
	        mipsFunction.instructions.add(1, new MIPSInstruction(MIPSOp.MOVE, null, 
	        		regs.get("$fp"), regs.get("$sp")));
	    }



		//// UPDATE (4/22/20): mips-interpreter sometimes fails due to uninitialized registers; here's a dumb fix:
        if ("main".equalsIgnoreCase(mipsFunction.name)) {
	        for (String regName : tempRegNames) {
				curFunction.instructions.add(new MIPSInstruction(MIPSOp.LI, null, 
						regs.get(regName), ZERO));
			}
		}

		
        int stackFrameSize = 0;

//---------------------------------------------------------------------------------------------------

		/* Stack Frame Prologue Step #2: Allocate sufficient space for the Local Data Storage Section */
		int local_data_size = SAVE_RESTORE_FROM_FP ? 40 : 0;	//// Includes space for all 10 temporary regs, so always at least 10 words in size
//// FIXME
		if (!irFunction.variables.isEmpty()) {
			for (IRVariableOperand irVar : irFunction.variables) {

				/// TODO: Check if is IRArrayType!!
				if (irVar.type instanceof IRArrayType) {
					String arrName = irVar.toString();
					int arrSize = ((IRArrayType) irVar.type).size;
					Addr arrEnd = new Addr(new Imm(String.valueOf((local_data_size+4)*(-1))), 
							regs.get("$fp"));
					local_data_size += (arrSize * 4);
					Addr arrStart = new Addr(new Imm(String.valueOf(local_data_size*(-1))),
							regs.get("$fp"));
					MIPSArray mipsArray = new MIPSArray(arrName, arrSize, arrStart, arrEnd, mipsFunction);
					
					//// FOR DEBUG
					// mipsArray.printArrayInfo();
					//// FOR DEBUG

					mipsFunction.variables.add((MIPSOperand) mipsArray);
					processedArrays.put(arrName, mipsArray);
				} else {
					MIPSOperand mipsVar = getMappedReg(irVar.toString());
					mipsFunction.variables.add(mipsVar);
					local_data_size += 4;
				}
			}
		}

		stackFrameSize += (local_data_size);

//---------------------------------------------------------------------------------------------------

		/* Stack Frame Prologue Step #3: Ensure the Local Data Segment ends on a double word boundary by inserting a Pad */
		while (stackFrameSize % 8 != 0) {
			stackFrameSize += 4;
		}

//---------------------------------------------------------------------------------------------------

		/* Stack Frame Prologue Step #4: Calculate size of Arguments Section (max # of args passed to any subroutine to be called) */
/*
		int argumentsSize = 4;		//// Minimum size is 4
		int maxArgsInCall = 0;
		for (IRInstruction inst : irFunction.instructions) {
			int numArgs = 0;
			if (inst.opCode == CALL) {
				numArgs = inst.operands.length - 1;
			} else if (inst.opCode == CALLR) {
				numArgs = inst.operands.length - 2;
			}

			if (numArgs > maxArgsInCall) {
				maxArgsInCall = numArgs;
			}
		}
		argumentsSize += maxArgsInCall;
		stackFrameSize += argumentsSize;
*/

		// mipsFunction.frameSize += (local_data_size * 4);
		mipsFunction.frameSize = stackFrameSize;
		mipsFunction.instructions.add(new MIPSInstruction(MIPSOp.ADDI, null,
				regs.get("$sp"), 
				regs.get("$sp"),
				// new Imm(String.valueOf(local_data_size * -4))));
				new Imm(String.valueOf(stackFrameSize * -1))));


//// FIXME
//// FIXME
		if (!irFunction.parameters.isEmpty()) {
			mipsFunction.instructions.add(new MIPSInstruction(MIPSOp.COMMENT, 
					"Fetch arguments from stack & collapse", 
					(MIPSOperand) null));
			/*
				Must compute the size of params & vars for the function
				then generate instructions to reserve stack space:
					"addi $sp, $sp, -104"
				^ UPDATE: Caller should probs do this
			*/

			// int stackSpace = 0;
			int argOffset = stackFrameSize;  // 8;

			List<IRVariableOperand> irParamsReversed = new LinkedList<>(irFunction.parameters);
			Collections.reverse(irParamsReversed);
			// for (IRVariableOperand irParam : irFunction.parameters) {
			for (IRVariableOperand irParam : irParamsReversed) {
				MIPSOperand mipsParam = getArgumentReg(irParam.toString());
				// MIPSOperand mipsParam = getMappedReg(irParam.toString());
				mipsFunction.parameters.add(mipsParam);

/*
				//// Stack pointer should initially currently pointing to the last argument
				//// lw $t_, 0($sp)
				mipsFunction.instructions.add(new MIPSInstruction(MIPSOp.LW, null,
						mipsParam,
						stackPointer));

				//// addi $sp, $sp, 4
				mipsFunction.instructions.add(new MIPSInstruction(MIPSOp.ADDI, null,
						regs.get("$sp"), 
						regs.get("$sp"),
						wordSize));
*/


				//// UPDATE (4/22/20): Stack pointer should initially be pointing to top of current stack frame
				mipsFunction.instructions.add(new MIPSInstruction(MIPSOp.LW, null,
						mipsParam,
						new Addr(new Imm(String.valueOf(argOffset)), regs.get("$sp"))));

				argOffset += 4;
				
				// stackSpace -= 4;	// Is this correct???
			}
			// mipsFunction.instructions.add(new MIPSInstruction(MIPSOp.ADDI, null,
			// 		regs.get("$sp"), regs.get("$sp"),
			// 		new Imm(String.valueOf(stackSpace))));
		}
//// FIXME

//---------------------------------------------------------------------------------------------------

		if (irFunction.returnType != null) {
			mipsFunction.returnType = irFunction.returnType.toString();
		}

		mipsFunction.instructions.add(new MIPSInstruction(MIPSOp.COMMENT, 
					"End of prologue", 
					(MIPSOperand) null));

//---------------------------------------------------------------------------------------------------

		//// Now, translate each IR instruction into MIPS counterpart(s)
		for (IRInstruction irInst : irFunction.instructions) {
			List<MIPSInstruction> parsedInst = parseInstruction(irInst, irFunction.name);
			// for (MIPSInstruction mipsInst : parsedInst) {
			// 	mipsFunction.instructions.add(mipsInst);
			// }
			mipsFunction.instructions.addAll(parsedInst);
		}

//---------------------------------------------------------------------------------------------------

		mipsFunction.instructions.add(new MIPSInstruction(MIPSOp.COMMENT, 
					"Start of epilogue", 
					(MIPSOperand) null));
//// FIXME
		//// Collapse the stack
		mipsFunction.instructions.add(new MIPSInstruction(MIPSOp.ADDI, null,
				regs.get("$sp"), 
				regs.get("$sp"),
				// new Imm(String.valueOf(local_data_size * 4))));
				new Imm(String.valueOf(stackFrameSize))));
//// FIXME
		mipsFunction.instructions.add(new MIPSInstruction(MIPSOp.COMMENT, 
					"End of epilogue", 
					(MIPSOperand) null));

//---------------------------------------------------------------------------------------------------

		//// If not main function, append a return ("jr $ra") instruction at the end
		if (!"main".equalsIgnoreCase(mipsFunction.name)) {
			mipsFunction.instructions.add(new MIPSInstruction(MIPSOp.COMMENT, 
					"Return from subroutine " + mipsFunction.name, 
					(MIPSOperand) null));
			mipsFunction.instructions.add(new MIPSInstruction(MIPSOp.JR, null,
					regs.get("$ra")));
		}

		return mipsFunction;
	}


	public List<MIPSInstruction> parseInstruction(IRInstruction irInst, String parentName) {
		if (curFunction == null) {
			curFunction = new MIPSFunction(parentName);
			processedFunctions.add(curFunction);
		}
		List<MIPSInstruction> parsedInst = new LinkedList<>();

		MIPSInstruction mipsInst;
		MIPSOp op = null;
		String label = null;
		MIPSOperand[] mipsOperands = null;// = new MIPSOperand[irInst.operands.length];

		switch(irInst.opCode) {
			case LABEL:
				label = new String(irInst.operands[0].toString() + "_" + parentName);
				op = MIPSOp.LABEL;
				parsedInst.add(new MIPSInstruction(op, label, mipsOperands));
				curFunction.labelMap.put(label, new Addr(label));
				// return parsedInst;
				break;

			case ASSIGN:
				//// CHECK IF AN ARRAY ASSIGNMENT && HANDLE ACCORDINGLY
				if (IRUtil.isArrayAssignment(irInst)) {
					//// operand[0] will be an array
					//// operand[1] will be the size of the array (int)
					//// operand[2] will be the value to populate the array with (likely int, same type as array)
					String arrName = irInst.operands[0].toString();  //((IRArrayType) ((IRVariableOperand) irInst.operands[0]).type).name;
					MIPSArray arrOperand = processedArrays.get(arrName);
					String arrStartRegName = arrName + "Base";
					Register arrStartReg = getMappedReg(arrStartRegName);

					//// "la arrayBase, -128($fp)"
					parsedInst.add(new MIPSInstruction(MIPSOp.LA, null, 
							arrStartReg,
							arrOperand.start));

					String sizeValStr = ((IRConstantOperand) irInst.operands[1]).getValueString();
					Imm arrSizeVal = new Imm(sizeValStr);
					String arrSizeValName = arrName + "Size";
					Register arrSizeValReg = getMappedReg(arrSizeValName);

					//// "li arraySize, 32"
					parsedInst.add(new MIPSInstruction(MIPSOp.LI, null, 
							arrSizeValReg,
							arrSizeVal));

					String arrValStr = ((IRConstantOperand) irInst.operands[2]).getValueString();
					Imm arrVal = new Imm(arrValStr);
					String arrValName = arrName + "Value";
					Register arrValReg = getMappedReg(arrValName);

					//// "li arrayValue, 10"
					parsedInst.add(new MIPSInstruction(MIPSOp.LI, null, 
							arrValReg,
							arrVal));

					label = new String(arrName + "ArrAssignLoop_" + parentName);
					parsedInst.add(new MIPSInstruction(MIPSOp.LABEL, 
							label,
							(MIPSOperand) null));
					if (!curFunction.labelMap.containsKey(label)) {
						curFunction.labelMap.put(label, new Addr(label));
					}


					String arrIdxStr = arrName + "Idx";
					Register arrIdxReg = getMappedReg(arrIdxStr);

					//// "addi arrayIdx, arrayBase, 0"
					parsedInst.add(new MIPSInstruction(MIPSOp.ADDI, null, 
							arrIdxReg,
							arrStartReg,
							ZERO));

					//// "sw arrayValue, 0(arrayIdx)"
					parsedInst.add(new MIPSInstruction(MIPSOp.SW, null, 
							arrValReg,
							new Addr(arrIdxReg)));

					//// "addi arrayBase, arrayBase, 4"
					parsedInst.add(new MIPSInstruction(MIPSOp.ADDI, null, 
							arrStartReg,
							arrStartReg,
							wordSize));

					//// "addi arraySize, arraySize, -1"
					parsedInst.add(new MIPSInstruction(MIPSOp.ADDI, null, 
							arrSizeValReg,
							arrSizeValReg,
							// new Imm("-1")));
							NEG_ONE));

					//// "bgt arraySize, $zero, arrayArrAssignLoop_main"
					parsedInst.add(new MIPSInstruction(MIPSOp.BGT, null, 
							arrSizeValReg,
							USING_SPIM ? regs.get("$0") : regs.get("zero"),
							curFunction.labelMap.get(label)));
				} else {
					//// operand[0] will be a register/variable,
					//// operand[1] will be either a var or constant
					mipsOperands = new MIPSOperand[irInst.operands.length];
					Register destination = getMappedReg(irInst.operands[0].toString());
					mipsOperands[0] = destination;
					MIPSOperand source = null;
					if (irInst.operands[1] instanceof IRConstantOperand) {
						op = MIPSOp.LI;
						String constVal = ((IRConstantOperand) irInst.operands[1]).getValueString();
						//// TODO: Add support for "FLOAT" types, currently only checking for hex & dec
						String constType = ((constVal.toLowerCase()).indexOf('x') >= 0) 
										? "HEX" : "DEC";
						source = new Imm(constVal, constType);
						curFunction.assignments.put(destination.name, ((Imm) source).getInt());
					} else if (irInst.operands[1] instanceof IRLabelOperand
							|| irInst.operands[1] instanceof IRFunctionOperand) {
						op = MIPSOp.LA;
						String addrName = irInst.operands[1].toString();
						source = new Addr(addrName);
						if (!curFunction.labelMap.containsKey(addrName)) {
							curFunction.labelMap.put(addrName, (Addr) source);
						}
					} else {
						op = MIPSOp.MOVE;
						source = getMappedReg(irInst.operands[1].toString());
					}
					mipsOperands[1] = source;
					parsedInst.add(new MIPSInstruction(op, label, mipsOperands));
				}
				break;

			case ADD:
				parseBinaryOp(parsedInst, MIPSOp.ADD, MIPSOp.ADDI, irInst.operands);
				break;

			case SUB:
				parseBinaryOp(parsedInst, MIPSOp.SUB, null, irInst.operands);
				break;

			case MULT:
				parseBinaryOp(parsedInst, MIPSOp.MUL, null, irInst.operands);
				break;

			case DIV:
				// TODO (optional): Can check if last operand is a power of 2 and replace DIV with SLL
				parseBinaryOp(parsedInst, MIPSOp.DIV, null, irInst.operands);
				break;
			
			case AND:
				parseBinaryOp(parsedInst, MIPSOp.AND, MIPSOp.ANDI, irInst.operands);
				break;
			
			case OR:
				parseBinaryOp(parsedInst, MIPSOp.OR, MIPSOp.ORI, irInst.operands);
				break;
			
			case BREQ:	// breq, Label, Rs, Rt --> BEQ Rs, Rt, Label
				// parsedInst.add(parseBranch(MIPSOp.BEQ, irInst.operands)); //, parentName));
				parseBranch(parsedInst, MIPSOp.BEQ, irInst.operands);
				break;
			
			case BRNEQ:	// brneq, Label, Rs, Rt --> BNE Rs, Rt, Label
				// parsedInst.add(parseBranch(MIPSOp.BNE, irInst.operands)); //, parentName));
				parseBranch(parsedInst, MIPSOp.BNE, irInst.operands);
				break;
			
			case BRLT:	// brlt, Label, Rs, Rt --> BLT Rs, Rt, Label
				// parsedInst.add(parseBranch(MIPSOp.BLT, irInst.operands)); //, parentName));
				parseBranch(parsedInst, MIPSOp.BLT, irInst.operands);
				break;
			
			case BRGT:	// brgt, Label, Rs, Rt --> BGT Rs, Rt, Label
				// parsedInst.add(parseBranch(MIPSOp.BGT, irInst.operands)); //, parentName));
				parseBranch(parsedInst, MIPSOp.BGT, irInst.operands);
				break;
			
			case BRLEQ:	// brleq, Label, Rs, Rt -->  BLT Rs, Rt, Label; BEQ Rs, Rt, Label
				//// beq $t0, $t1, Label 		# if $t0 = $t1, goes to Label
				//// slt $t2, $t1, $t0 		# checks if $t0 > $t1
				//// beq $t2, zero, Label 	# if $t0 < $t1, goes to Label
				// parsedInst.add(parseBranch(MIPSOp.BLT, irInst.operands)); //, parentName));
				// parsedInst.add(parseBranch(MIPSOp.BEQ, irInst.operands)); //, parentName));
				parseBranch(parsedInst, MIPSOp.BLT, irInst.operands);
				parseBranch(parsedInst, MIPSOp.BEQ, irInst.operands);
				break;
			
			case BRGEQ:	// brgeq, Label, Rs, Rt --> BGE Rs, Rt, Label
				// parsedInst.add(parseBranch(MIPSOp.BGE, irInst.operands)); //, parentName));
				parseBranch(parsedInst, MIPSOp.BGE, irInst.operands);
				break;

			case GOTO:
        		op = MIPSOp.J;
        		Addr jumpTarget = null;
				IRLabelOperand irTarget = (IRLabelOperand) irInst.operands[0];
				String labelName = new String(irTarget.getName() + "_" + parentName);

				if (curFunction.labelMap.containsKey(labelName)) {
					jumpTarget = curFunction.labelMap.get(labelName);
				} else if (curFunction.labelMap.containsKey(irTarget.getName())) {
					jumpTarget = curFunction.labelMap.get(irTarget.getName());
				} else {
					jumpTarget = new Addr(labelName);
					curFunction.labelMap.put(labelName, jumpTarget);
				}
				parsedInst.add(new MIPSInstruction(op, label, jumpTarget));
				break;
			
			case RETURN:
				parsedInst.add(new MIPSInstruction(MIPSOp.COMMENT, 
					"Store return value in $v0 and return", 
					(MIPSOperand) null));
				//// Store return value in $v0 (if applicable)
				parsedInst.add(new MIPSInstruction(MIPSOp.MOVE, null, 
						regs.get("$v0"), 
						getMappedReg(irInst.operands[0].toString())));
				break;
			
			case CALL:
				String subroutineName = ((IRFunctionOperand) irInst.operands[0]).getName();
				if (Arrays.asList(intrinsicFunctions).contains(subroutineName)) {
					parsedInst.addAll(parseIntrinsicFunction(subroutineName, irInst.operands));
				} else {
					parseUserFunction(subroutineName, parsedInst, irInst.operands, (Register) null);
				}
				break;	

			case CALLR:
				subroutineName = ((IRFunctionOperand) irInst.operands[1]).getName();
				if (Arrays.asList(intrinsicFunctions).contains(subroutineName)) {
					parsedInst.addAll(parseIntrinsicFunction(subroutineName, irInst.operands));
				} else {
					Register destination = getMappedReg(irInst.operands[0].toString());
					parseUserFunction(subroutineName, parsedInst, irInst.operands, destination);
				}
				break;
			
			case ARRAY_STORE:	//// array_store, a, arr, 0  -->  arr[0] := a
				parseArrayOp(parsedInst, irInst.operands, false);
				break;
			
			case ARRAY_LOAD:	//// array_load, a, arr, 0  -->  a := arr[0]
				parseArrayOp(parsedInst, irInst.operands, true);
				break;
			
			default:
				// return parsedInst;
		}
		return parsedInst;
	}


	private void parseBinaryOp(List<MIPSInstruction> parsedInst,
								MIPSOp opcode1, MIPSOp opcode2, 
                                        IROperand[] operands) {
        MIPSOperand[] mipsOperands = new MIPSOperand[operands.length];
        MIPSOp op = opcode1;

        if (opcode2 != null) {
	        for (IROperand o : operands) {
	            if (o instanceof IRConstantOperand) {
	                op = opcode2;
	                break;
	            }
	        }
	    }

        String destination = ((IRVariableOperand) operands[0]).getName();
        mipsOperands[0] = (MIPSOperand) getMappedReg(destination);
        for (int i = 1; i < 3; i++) {
            if (operands[i] instanceof IRConstantOperand) {
            	if (opcode2 != null) {
	                IRType type = ((IRConstantOperand) operands[i]).type;
	                mipsOperands[i] = new Imm(operands[i].toString(), 
	                    "DEC");     // For now: only handling integers, floats are extra credit
	                curFunction.assignments.put(destination, ((Imm) mipsOperands[i]).getInt());
	            } else {
	            	//// SUB, MUL, and DIV cannot accept an immediate value as an operand...
	            	//// First, load the immediate value into a register, then perform binary op on the reg
	            	Register t = getMappedReg("temp");
	            	Imm imm = new Imm(operands[i].toString());
	            	parsedInst.add(new MIPSInstruction(MIPSOp.LI, null,
	            			/*(MIPSOperand)*/ t, 
	            			/*(MIPSOperand)*/ imm));
	            	mipsOperands[i] = (MIPSOperand) t;
	            }
            } 
            else {
                mipsOperands[i] = (MIPSOperand) getMappedReg(operands[i].toString());
            }
        }

        // return new MIPSInstruction(op, null, mipsOperands);
        parsedInst.add(new MIPSInstruction(op, null, mipsOperands));
    }

    // private List<MIPSInstruction> parseBranch(MIPSOp opcode1, MIPSOp opcode2, 
    private void parseBranch(List<MIPSInstruction> parsedInst,
								MIPSOp op, IROperand[] operands) { 
        MIPSOperand[] mipsOperands = new MIPSOperand[operands.length];
        Addr branchTarget = null;
        String labelName = operands[0].toString();
        String branchTargetName = new String(labelName + "_" + curFunction.name); //parentFuncName);

        if (curFunction.labelMap.containsKey(branchTargetName)) {
            branchTarget = curFunction.labelMap.get(branchTargetName);
        } else if (curFunction.labelMap.containsKey(labelName)) {
            branchTarget = curFunction.labelMap.get(labelName);
        } else {
            branchTarget = new Addr(branchTargetName);
            curFunction.labelMap.put(branchTargetName, branchTarget);
        }
        mipsOperands[2] = branchTarget;

        for (int i = 1; i <= 2; i++) {
            if (operands[i] instanceof IRConstantOperand) {
            	//// SPIM does not support constant operands for branches! Must first save to a register
            	/*
                if (((IRConstantOperand) operands[i]).type instanceof IRIntType) {
                    mipsOperands[i-1] = new Imm(operands[i].toString()); //, "DEC");
                } else {
                    mipsOperands[i-1] = new Imm(operands[i].toString(), "?");
                }
                */
                Register t = getMappedReg("temp");
                Imm imm = new Imm(((IRConstantOperand) operands[i]).getValueString());
                parsedInst.add(new MIPSInstruction(MIPSOp.LI, null, t, imm));
                mipsOperands[i-1] = t;
            } else {
                mipsOperands[i-1] = getMappedReg(operands[i].toString());
            }
        }

        parsedInst.add(new MIPSInstruction(op, null, mipsOperands));
    }

    /*
	    # print integer in $t0
	    ### Tiger-IR:   call, puti, t0
	    li $v0, 1   # print int
	    # li $v0, 11    # print char
	    move $a0, $t0
	    syscall

	    ### Tiger-IR:   call, putc, 10
	    li $v0, 11  # print space
	    li $a0, 10
	    syscall
	*/
	private List<MIPSInstruction> parseIntrinsicFunction(String name, IROperand[] operands) {
		List<MIPSInstruction> parsedFunc = new LinkedList<>();
		MIPSOperand[] mipsOperands;
		Imm serviceCode = null;
		MIPSOperand destination = null;
		switch(name) {
			    				//// TODO: Account for function calls with non-int/char params & more than 1 param
			case "puti":		//// print_int
				parsedFunc.add(new MIPSInstruction(MIPSOp.COMMENT, "print_int", 
						(MIPSOperand) null));
				//// li $v0, 1     
				serviceCode = systemServiceCodes.get("print_int");
				parsedFunc.add(new MIPSInstruction(MIPSOp.LI, null, regs.get("$v0"), serviceCode));

				//// move $a0, intToPrint
				String intToPrint = operands[1].toString();
				MIPSOp opcode = null;
				mipsOperands = new MIPSOperand[2];
				mipsOperands[0] = regs.get("$a0");
				
				if (operands[1] instanceof IRConstantOperand) {
					mipsOperands[1] = new Imm(intToPrint);
					opcode = MIPSOp.LI;
				} else { //if (irInst.operands[1] instanceof IRVariableOperand) {
					mipsOperands[1] = getMappedReg(intToPrint);
					opcode = MIPSOp.MOVE;
				}
				parsedFunc.add(new MIPSInstruction(opcode, null, mipsOperands));

				//// syscall
				parsedFunc.add(new MIPSInstruction(MIPSOp.SYSCALL, null, (MIPSOperand) null));
				break;
			
			case "putc":		//// print_char
				parsedFunc.add(new MIPSInstruction(MIPSOp.COMMENT, "print_char", 
						(MIPSOperand) null));
				//// li $v0, 11 
				serviceCode = systemServiceCodes.get("print_char");
				parsedFunc.add(new MIPSInstruction(MIPSOp.LI, null, regs.get("$v0"), serviceCode));

				//// li $a0, charToPrint  # e.g., 10 to print a space character
				String charToPrint = operands[1].toString();
				opcode = null;
				mipsOperands = new MIPSOperand[2];
				mipsOperands[0] = regs.get("$a0");

				if (operands[1] instanceof IRConstantOperand) {
					mipsOperands[1] = new Imm(charToPrint);
					opcode = MIPSOp.LI;
				} else { //if (operands[1] instanceof IRVariableOperand) {
					mipsOperands[1] = getMappedReg(charToPrint);
					opcode = MIPSOp.MOVE;
				}
				parsedFunc.add(new MIPSInstruction(opcode, null, mipsOperands));

				//// syscall
				parsedFunc.add(new MIPSInstruction(MIPSOp.SYSCALL, null, (MIPSOperand) null));
				break;

			case "putf":
				//// TODO
				if (!SUPPORT_FLOATS) {
					System.out.println("[parseIntrinsicFunction] ERROR: call to 'putf' not supported!");
				}
				break;

			case "geti":		//// read_int
				parsedFunc.add(new MIPSInstruction(MIPSOp.COMMENT, "read_int", 
						(MIPSOperand) null));
				//// li $v0, 5
				serviceCode = systemServiceCodes.get("read_int");
				parsedFunc.add(new MIPSInstruction(MIPSOp.LI, null, regs.get("$v0"), serviceCode));

				//// syscall (will store int read from keyboard into $v0)
				parsedFunc.add(new MIPSInstruction(MIPSOp.SYSCALL, null, (MIPSOperand) null));

				// //// sw $v0, intValue
				// MIPSOperand intValue = 

				//// move destination, $v0  
				// MIPSOperand destination;
				if (operands[0] instanceof IRVariableOperand) {
					destination = getMappedReg(operands[0].toString());
				} else {	//// Should never be the case
					destination = new Addr(operands[0].toString());
				}
				parsedFunc.add(new MIPSInstruction(MIPSOp.MOVE, null, destination, regs.get("$v0")));
				break;

			case "getc":		//// read_string (for a single char)
				parsedFunc.add(new MIPSInstruction(MIPSOp.COMMENT, "read_char", 
						(MIPSOperand) null));
				mipsOperands = new MIPSOperand[2];
				serviceCode = systemServiceCodes.get("read_string");
				//// li $v0, 8
				parsedFunc.add(new MIPSInstruction(MIPSOp.LI, null, regs.get("$v0"), serviceCode));

				//// la $a0, bufferAddr
				mipsOperands[0] = regs.get("$a0");
				destination = getMappedReg(((IRVariableOperand) operands[0]).getName());
				mipsOperands[1] = new Addr((Register) destination);
				parsedFunc.add(new MIPSInstruction(MIPSOp.LA, null, mipsOperands));

				//// li $a1, lengthOfOne
				parsedFunc.add(new MIPSInstruction(MIPSOp.LI, null, regs.get("$a1"), new Imm("1")));
				break;

			case "getf":
				//// TODO
				if (!SUPPORT_FLOATS) {
					System.out.println("[parseIntrinsicFunction] ERROR: call to 'getf' not supported!");
				}
				break;
			
			default:
				break;
		}

		return parsedFunc;
	}

	private void parseUserFunction(String subroutineName, List<MIPSInstruction> parsedInst, 
												IROperand[] operands, Register destination) {

		//// Preserve contents of $t0..$t9 on the stack
		saveTempRegs(parsedInst);

		//// Save current frame pointer $fp in stack ("sw $fp, 0($sp)")
		// parsedInst.add(new MIPSInstruction(MIPSOp.COMMENT, 
		// 		"Save return address $ra in stack", 
		// 		(MIPSOperand) null));
		// parsedInst.add(new MIPSInstruction(MIPSOp.ADDI, null, 
		// 		regs.get("$sp"), 
		// 		regs.get("$sp"),
		// 		negWordSize));
		// parsedInst.add(new MIPSInstruction(MIPSOp.SW, null, 
		// 		regs.get("$fp"), 
		// 		stackPointer));
		parsedInst.add(new MIPSInstruction(MIPSOp.MOVE, null,
				regs.get("$s6"),
				regs.get("$fp")));

		//// Save return address $ra in stack ("sw $ra, 0($sp)")
		// parsedInst.add(new MIPSInstruction(MIPSOp.COMMENT, 
		// 		"Save return address $ra in stack", 
		// 		(MIPSOperand) null));
		parsedInst.add(new MIPSInstruction(MIPSOp.ADDI, null, 
				regs.get("$sp"), 
				regs.get("$sp"),
				negWordSize));
		parsedInst.add(new MIPSInstruction(MIPSOp.SW, null, 
				regs.get("$ra"), 
				stackPointer));

		//// Load parameters for the function call ("addi $sp, $sp, stackSpace")
		int stackSpace = 0; // = (irInst.operands.length/*-1*/) * (-4);	// Correct? (likely not...)
		
		//// Push all arguments onto the stack
		parsedInst.add(new MIPSInstruction(MIPSOp.COMMENT, 
				"Pushing function call args onto stack", 
				(MIPSOperand) null));

		int idx = destination == null ? 1 : 2;
		for (; idx < operands.length; idx++) {
			parsedInst.add(new MIPSInstruction(MIPSOp.ADDI, null, 
					regs.get("$sp"), 
					regs.get("$sp"),
					negWordSize));

			stackSpace += 4;
			MIPSOperand arg = null;
			IROperand param = operands[idx];
			if (param instanceof IRVariableOperand) {
				arg = getMappedReg(param.toString());
				if (arg == null || ((Register) arg).name.contains(curFunction.name)) {
					arg = getArgumentReg(param.toString());
				}
			} else if (param instanceof IRConstantOperand) {
				Imm argVal = new Imm(((IRConstantOperand) param).getValueString());
				if (argVal.getInt() == 0) {
					arg = USING_SPIM ? regs.get("$0") : regs.get("zero");
				} else {
					String argRegName = param.toString() + curFunction.name;
					arg = getMappedReg(argRegName);
					parsedInst.add(new MIPSInstruction(MIPSOp.LI, null, arg, argVal));
				}
			} else {
				// arg = new Addr(param.toString());	// prolly invalid
				arg = processedArrays.get(param.toString());
				if (arg == null) {
					System.out.println("[CALL] ERROR: Invalid function argument type");
				}
			}
			parsedInst.add(new MIPSInstruction(MIPSOp.SW, null,
					arg, stackPointer));
		}

		//// Jump and link to the function ("jal functionName")
		parsedInst.add(new MIPSInstruction(MIPSOp.COMMENT, 
				"Calling subroutine '"+subroutineName+"'", 
				(MIPSOperand) null));
		Addr labelAddr = null;
		if (curFunction.labelMap.containsKey(subroutineName)) {
			labelAddr = curFunction.labelMap.get(subroutineName);
		} else {
			for (MIPSFunction func : processedFunctions) {
				if (subroutineName.equals(func.name)) {
					labelAddr = new Addr(func.name);
					curFunction.labelMap.put(func.name, labelAddr);
					break;
				}
			}
			if (labelAddr == null) {
				labelAddr = new Addr(subroutineName);
				curFunction.labelMap.put(subroutineName, labelAddr);
			}
		}
		parsedInst.add(new MIPSInstruction(MIPSOp.JAL, null, labelAddr));

		/* UPDATE: I believe this is done by the callee
		//// Collapse the stack:
		parsedInst.add(new MIPSInstruction(MIPSOp.ADDI, null, 
				regs.get("$sp"), regs.get("$sp"),
				new Imm(String.valueOf(stackSpace))));
		*/

		//// Pop the function call arguments from the stack
		parsedInst.add(new MIPSInstruction(MIPSOp.ADDI, null, 
				regs.get("$sp"), regs.get("$sp"),
				new Imm(String.valueOf(stackSpace))));


		//// Restore return address
		// parsedInst.add(new MIPSInstruction(MIPSOp.COMMENT, 
		// 		"Restoring return address", 
		// 		(MIPSOperand) null));
		////	"lw $ra, 0($sp)"
		////	"addi $sp, $sp, 4"
		parsedInst.add(new MIPSInstruction(MIPSOp.LW, null, 
				regs.get("$ra"),
				stackPointer));
		parsedInst.add(new MIPSInstruction(MIPSOp.ADDI, null, 
				regs.get("$sp"), regs.get("$sp"),
				// new Imm(String.valueOf(stackSpace))));	// <-- need this???
				// new Imm("4")));
				wordSize));

		//// Restore frame pointer
		// parsedInst.add(new MIPSInstruction(MIPSOp.LW, null, 
		// 		regs.get("$fp"),
		// 		stackPointer));
		// parsedInst.add(new MIPSInstruction(MIPSOp.ADDI, null, 
		// 		regs.get("$sp"), regs.get("$sp"),
		// 		wordSize));

		parsedInst.add(new MIPSInstruction(MIPSOp.MOVE, null,
				regs.get("$fp"),
				regs.get("$s6")));
			

		restoreTempRegs(parsedInst);

		//// If CALLR, load result from call (in $v0) into destination register
		if (destination != null) {
			parsedInst.add(new MIPSInstruction(MIPSOp.COMMENT, 
					"Load return value in $v0 into the destination register", 
					(MIPSOperand) null));
			parsedInst.add(new MIPSInstruction(MIPSOp.MOVE, null, 
					destination,
					regs.get("$v0")));
		}
	}

	public void parseArrayOp(List<MIPSInstruction> parsedInst, 
							IROperand[] operands, boolean isLoad) {
		//// array_load/_store, a, arr, 0  -->  a := arr[0] / arr[0] := a
		//// operands[0] is the destination register (must be a variable)
		//// operands[1] is the array name
		//// operands[2] is the integer offset into the array
		String arrName = operands[1].toString();  //((IRArrayType) ((IRVariableOperand) irInst.operands[0]).type).name;
		MIPSArray arrOperand = processedArrays.get(arrName);
		String arrStartRegName = arrName + "Base";
		Register arrStartReg = getMappedReg(arrStartRegName);

		//// "la arrayBase, -128($fp)"  <--  arrayBase will now point to array[0]
		parsedInst.add(new MIPSInstruction(MIPSOp.LA, null, 
				arrStartReg,
				arrOperand.start));

		String offsetIntoArrRegName = null;
		Register offsetIntoArrReg = null;
		String suffix = isLoad ? "LoadOffset" : "StoreOffset";
		if (operands[2] instanceof IRConstantOperand) {
			//// If offset value is constant, need to store its value into a register (using load immediate instruction)
			MIPSOperand offsetIntoArr = new Imm(String.valueOf(((IRConstantOperand) 
					operands[2]).getValueString()));
			offsetIntoArrRegName = arrName + suffix;
			offsetIntoArrReg = getMappedReg(offsetIntoArrRegName);
			parsedInst.add(new MIPSInstruction(MIPSOp.LI, null,
				offsetIntoArrReg,
				offsetIntoArr));
		} else {
			offsetIntoArrRegName = operands[2].toString(); // + suffix;
			offsetIntoArrReg = getMappedReg(offsetIntoArrRegName);
		}

		String shiftedOffsetName = offsetIntoArrRegName + "Shifted";
		Register shiftedOffsetReg = getMappedReg(shiftedOffsetName);
		
		//// Left shift offset value by 2 to reach a word boundary (same as 4 * offset)
		parsedInst.add(new MIPSInstruction(MIPSOp.SLL, null,
				// offsetIntoArrReg,	//// <-- Causes issues when future instructions try to reuse value
				shiftedOffsetReg,
				offsetIntoArrReg,
				TWO));

		//// Add word offset relative to the array's base address
		parsedInst.add(new MIPSInstruction(MIPSOp.ADD, null,
				arrStartReg,
				arrStartReg,
				shiftedOffsetReg));		// offsetIntoArrReg));

		//// Finally...
		if (isLoad) {
			//// Load the memory contents of (arrayBase + wordOffset) into destination register
			Register destination = getMappedReg(operands[0].toString());
			parsedInst.add(new MIPSInstruction(MIPSOp.LW, null,
					destination,
					new Addr(arrStartReg)));
		} else {
			//// Store the desired value into (arrayBase + wordOffset)
			Register valToStoreReg = null;
			if (operands[0] instanceof IRConstantOperand) {
				//// If value is constant, need to store its value into a register (using load immediate instruction)
				Imm valToStore = new Imm(String.valueOf(((IRConstantOperand) 
						operands[0]).getValueString()));
				String valToStoreRegName = arrName + "ValueToStore";
				valToStoreReg = getMappedReg(valToStoreRegName);
				parsedInst.add(new MIPSInstruction(MIPSOp.LI, null,
						valToStoreReg,
						valToStore));
			} else {
				valToStoreReg = getMappedReg(operands[0].toString());
			}

			parsedInst.add(new MIPSInstruction(MIPSOp.SW, null,
					valToStoreReg,
					new Addr(arrStartReg)));
		}
	}


	//// These instructions needed before any function call
	public void saveTempRegs(List<MIPSInstruction> convention) {
		convention.add(new MIPSInstruction(MIPSOp.COMMENT, 
				"Saving temporary regs", 
				(MIPSOperand) null));

		if (!SAVE_RESTORE_FROM_FP) {
			//// addi $sp, $sp, -40
			convention.add(new MIPSInstruction(MIPSOp.ADDI, null, 
					regs.get("$sp"), 
					regs.get("$sp"),
					negTempRegSpace));

			// convention.add(new MIPSInstruction(MIPSOp.SW, null,
			// 		regs.get(temp), 

			// 		tempRegFrameOffsets.get(temp)));
		}

		for (String temp : tempRegNames) {
			if (!SAVE_RESTORE_FROM_FP) {
				// //// addi $sp, $sp, -4
				// convention.add(new MIPSInstruction(MIPSOp.ADDI, null, 
				// 		regs.get("$sp"), 
				// 		regs.get("$sp"),
				// 		negWordSize));

				//// sw $t_, 0($sp)
				convention.add(new MIPSInstruction(MIPSOp.SW, null,
						regs.get(temp), 
						// stackPointer));
						tempRegOffsets.get(temp)[1]));
			}
			else {
				// System.out.println("[saveTempRegs] Saving " + temp + " into " + tempRegFrameOffsets.get(temp).toString());
				convention.add(new MIPSInstruction(MIPSOp.SW, null,
						regs.get(temp), 
						tempRegFrameOffsets.get(temp)));
			}
			
		}

		// return convention;	
	}

	//// These instructions needed after returning from a function call
	public void restoreTempRegs(List<MIPSInstruction> convention) {
		List<String> reversedRegNames = Arrays.asList(tempRegNames);      
      	Collections.reverse(reversedRegNames);

      	convention.add(new MIPSInstruction(MIPSOp.COMMENT, 
				"Restoring temporary regs", 
				(MIPSOperand) null));

		for (String temp : reversedRegNames) {
			if (!SAVE_RESTORE_FROM_FP) {
				//// lw $t_, 0($sp)
				convention.add(new MIPSInstruction(MIPSOp.LW, null,
						regs.get(temp),
						// stackPointer));
						tempRegOffsets.get(temp)[1]));

				//// addi $sp, $sp, 4
				// convention.add(new MIPSInstruction(MIPSOp.ADDI, null, 
				// 		regs.get("$sp"), 
				// 		regs.get("$sp"),
				// 		wordSize));
			}
			else {
				// System.out.println("[restoreTempRegs] Restoring " + temp + " from " + tempRegFrameOffsets.get(temp).toString());
				convention.add(new MIPSInstruction(MIPSOp.LW, null,
						regs.get(temp), 
						tempRegFrameOffsets.get(temp)));
			}
			
		}

		if (!SAVE_RESTORE_FROM_FP) {
			//// addi $sp, $sp, 40
			convention.add(new MIPSInstruction(MIPSOp.ADDI, null, 
					regs.get("$sp"), 
					regs.get("$sp"),
					posTempRegSpace));
		}
	}



	private void initializeRegisters() {
		regs = new HashMap<>();

		for (String name : tempRegNames) {
			////  $t0..$t9
			createRealReg(name);
		}

		for (String name : argRegNames) {
			////  $a0..$a3
			createRealReg(name);
		}

		createRealReg("zero");
		createRealReg("$0");
		// createRealReg("$at");

		createRealReg("$v0");
		createRealReg("$v1");

		createRealReg("$s0");
		createRealReg("$s1");
		createRealReg("$s2");
		createRealReg("$s3");
		createRealReg("$s4");
		createRealReg("$s5");
		createRealReg("$s6");
		createRealReg("$s7");

		// createRealReg("$k0");
		// createRealReg("$k1");

		createRealReg("$gp");
		createRealReg("$sp");
		createRealReg("$fp");
		createRealReg("$ra");
	}

	private void createRealReg(String name) {
		regs.put(name, new Register(name, false));
	}

	private void initializeSystemServices() {
		systemServiceCodes = new HashMap<>();
		systemServiceCodes.put("print_int", new Imm("1"));
		systemServiceCodes.put("print_float", new Imm("2"));
		systemServiceCodes.put("print_double", new Imm("3"));
		systemServiceCodes.put("print_string", new Imm("4"));
		systemServiceCodes.put("read_int", new Imm("5"));
		systemServiceCodes.put("read_float", new Imm("6"));
		systemServiceCodes.put("read_double", new Imm("7"));
		systemServiceCodes.put("read_string", new Imm("8"));
		systemServiceCodes.put("sbrk", new Imm("9"));
		systemServiceCodes.put("print_char", new Imm("11"));
	}

}