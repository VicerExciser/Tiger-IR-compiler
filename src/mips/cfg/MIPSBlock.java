package mips.cfg;

import mips.*;
import mips.cfg.*;
import mips.operand.*;
import ir.cfg.*;

import java.util.Set;
import java.util.TreeSet;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.LinkedList;
import java.util.Map;
import java.util.HashMap;

public class MIPSBlock implements Comparable<MIPSBlock> {

	public static int BLOCKNUM = 0;		//// Static counter for total # of blocks overall
	
	public MIPSFunction parentFunction;
	public String id;	// Block identifier generated by parent function
	public int blocknum;
	public Set<MIPSInstruction> instructions;
	public Set<MIPSBlock> predecessors;
	public Set<MIPSBlock> successors;
	public MaxBasicBlock associatedIRBlock;

	//// We need some data structures to record variables in each block, 
	//// variables' live range in each block, variables' registers, etc.
	public List</*MIPSOperand*/String> localVariables;
	public Map<String, LiveRange> varLiveRangeMap;
	public Map<String, String> irToMipsRegMap;		//// Primarily populated via RegAllocator.getMappedReg() function
	
	public Set<MIPSBlock> liveOut;
	public Set<MIPSBlock> liveIn;
	public Set<String> ueVarSet;	//// Upwards Exposed Variables: The set of names used 
									//// in this block before being defined in this block
	public Set<String> killVarSet;	//// The set of variables assigned in this block

	// public int size;
	// public MIPSInstruction leader;
	// public MIPSInstruction terminator;


	// public MIPSBlock(MIPSFunction parent) {
	// 	this(parent, null);
	// }

	public MIPSBlock(MIPSFunction parent, MaxBasicBlock associatedIRBlock) {
		this.parentFunction = parent;
		this.id = parent.getUniqueBlockID();
		this.associatedIRBlock = associatedIRBlock;
		this.instructions = new LinkedHashSet<>();
		this.localVariables = new LinkedList<>();
		this.varLiveRangeMap = new HashMap<>();
		this.irToMipsRegMap = new HashMap<>();
		this.predecessors = new TreeSet<>();
		this.successors = new TreeSet<>();
		this.liveOut = new LinkedHashSet<>();
		this.liveIn = new LinkedHashSet<>();
		this.ueVarSet = new LinkedHashSet<>();
		this.killVarSet = new LinkedHashSet<>();

		this.parentFunction.addBlock(this);		//// New blocks automatically added to parent function's CFG

		this.blocknum = BLOCKNUM;
		BLOCKNUM++;
	}


	public void appendInstruction(MIPSInstruction inst) {
		if (this.instructions.add(inst)) {		//// .add() will fail for duplicates
			inst.parentBlock = this;

			//// Add any variable assignments/definitions to this block's killVar set
			Register locallyAssigned = inst.getWrite();
			if (locallyAssigned != null && locallyAssigned.name.startsWith("$t")) {
				
				String varName = getVarNameForRegister(locallyAssigned);
				if (varName == null) {
					varName = parentFunction.getVarNameForRegister(locallyAssigned);
				}
				if (varName != null) {
					killVarSet.add(varName);

					if (irToMipsRegMap.get(varName) == null) {
						registerLocalVariable(varName, locallyAssigned.name);
					} else {
						addVar(varName);
					}
				}

				//// TEMPORARY IMPLEMENTATION - FOR DEBUG
				else {
					if (RegAllocator.getInstance().mode != RegAllocator.Mode.NAIVE) {
						System.out.println("\n  ~~~ [appendInstruction] " + this.toString()
								+ " failed to find the IR variable name associated with"
								+ " a local assignment to physical register " 
								+ locallyAssigned.toString() + " ~~~\n");
					}
				}
				//// TEMPORARY IMPLEMENTATION - FOR DEBUG

			}

		}

	}


	public String getVarNameForRegister(Register varReg) {
		return getVarNameForRegister(varReg.name);
	}

	public String getVarNameForRegister(String varRegName) {
		//// Attempt a reverse lookup in the block's irToMipsRegMap mappings
		String variableName = null;
		if (irToMipsRegMap.containsValue(varRegName)) {
			for (String key : irToMipsRegMap.keySet()) {
				if (varRegName.equals(irToMipsRegMap.get(key))) {
					variableName = key;
					break;
				}
			}
		}
		return variableName;
	}

	public int size() {
		return this.instructions.size();
	}

	public MIPSInstruction[] getInstructionsArray() {
		// return ((MIPSInstruction[]) ((Object[]) this.instructions.toArray()));
		return this.instructions.toArray(new MIPSInstruction[size()]);
	}

	public MIPSInstruction getLeader() {
		// return ((MIPSInstruction[]) this.instructions.toArray())[0];
		return getInstructionsArray()[0];
	}

	public MIPSInstruction getTerminator() {
		// return ((MIPSInstruction[]) this.instructions.toArray())[this.instructions.size()-1];
		return getInstructionsArray()[size()-1];
	}

	public void addVar(String irVar) {
		if (!this.localVariables.contains(irVar)) {
			this.localVariables.add(irVar);
		}
	}

	public void registerLocalVariable(String irVar, String assocRegName) {
		this.irToMipsRegMap.put(irVar, assocRegName);
		addVar(irVar);
	}

	public void removeVariable(String irVar) {
		this.localVariables.remove(irVar);
		this.irToMipsRegMap.remove(irVar);
		this.varLiveRangeMap.remove(irVar);
	}


	public void postProcess() {

		RegAllocator allocator = RegAllocator.getInstance();

		//// FOR DEBUG
		for (String v : localVariables) {
			if (!irToMipsRegMap.keySet().contains(v)) {
				System.out.println("\n [MIPSBlock::postProcess] ERROR #0:  irToMipsRegMap is missing local "
						+ "variable key!\n\t(variable = " + v + ")\n\t(block = " + id + ")\n");
			}
		}
		for (String v : irToMipsRegMap.keySet()) {
			if (!localVariables.contains(v)) {
				System.out.println("\n [MIPSBlock::postProcess] ERROR #1:  localVariables is missing map "
						+ "key!\n\t(variable = " + v + ")\n\t(block = " + id + ")\n");
			}
		}
		//// FOR DEBUG

		/**
			Live range is defined with respect to a variable:
			The live range of variable c starts from a definition of variable c and goes until  
			the next definition of the variable (in which place the variable gets killed, 
			or defined as a different variable, if you are using SSA), 
			or the end of the scope (block, function or program) that variable c exists.
		**/

		//// Perform live-range analysis for all local variables:
		MIPSInstruction[] blockInstructions = getInstructionsArray();

		for (String v : localVariables) {
			MIPSInstruction curInst;
			MIPSInstruction nextInst;

			//// A value v is live at program point p (i.e., a MIPSInstruction) if âˆƒ a path 
			//// from point p to some use of v along which v is not redefined. 

			// Register vReg = allocator.registers.get(irToMipsRegMap.get(v));
			Register vReg = allocator.getMappedRegForBlock(v, this);

			for (int i = 0; i < blockInstructions.length; i++) {
				curInst = blockInstructions[i];
				// if (!curInst.hasVariableOperands()) {
/*	
	curInst.getWrite():  Returns 1 destination register (or null if none)
	curInst.getReads():  Returns an array of source registers (or array of length 0 if none)
*/
				Register destReg = curInst.getWrite();
				Register[] srcRegs = curInst.getReads();
				if (destReg == null || srcRegs.length == 0) {
					continue;
				}

				boolean live = destReg.equals(vReg);
				if (!live) {
					for (int k = 0; k < srcRegs.length; k++) {
						live = live || srcRegs[k].equals(vReg);
					}
				}
				if (!live) {
					continue;
				}

				//// TODO: FINISH ME!


				for (int j = i+1; j < blockInstructions.length; j++) {
					nextInst = blockInstructions[j];
					if (nextInst.getWrite() == null || nextInst.getReads().length == 0) {
						continue;
					}

					//// FOR DEBUG
					// System.out.println(blockInstructions[i] + " - " + blockInstructions[j]);
					//// FOR DEBUG


				}
			}
		}
	}


	public void dumpInfo() {

	}

	public void printRegisterMapping() {
        String banner = "\n________________________________\n";
        System.out.println(banner + " Register Mapping for Basic Block "+this.toString()+":\n");
        for (String key : this.irToMipsRegMap.keySet()) {
            System.out.println("\t"+this.irToMipsRegMap.get(key).toString()+"  <--->  "+key);
        }
        System.out.println(banner);
    }


	@Override
	public String toString() {
		return id + "(B#"+String.valueOf(this.blocknum)+")";
	}

	@Override 
	public int compareTo(MIPSBlock other) {
		// return this.id.compareToIgnoreCase(other.id);
		return this.blocknum - other.blocknum;
	}

	@Override 
	public int hashCode() {
		int result = 17;
		result = 31 * result + this.parentFunction.name.toLowerCase().hashCode();
		result = 31 * result + this.id.hashCode();
		result = 31 * result + this.blocknum;
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (obj == null || !(obj instanceof MIPSBlock)) return false;
		if (this == obj) return true;
		MIPSBlock bbb = (MIPSBlock) obj;
		return this.id.equalsIgnoreCase(bbb.id)
				// && this.parent.name.equalsIgnoreCase(bbb.parent.name);
				// && this.leader.opCode == bbb.leader.opCode;
				&& this.hashCode() == bbb.hashCode();
	}
}
